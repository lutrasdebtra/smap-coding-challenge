# SMAP Coding Challenge Report
**Stuart Bradley**

## Initial Design Considerations

### Database and Model Design

For the coding challenge, the underlying data is cleanly divided into users, and their corresponding consumption time 
points.

Therefore, the simpliest model design is as follows:

- UserData:
    - id:IntegerField
    - area:CharField
    - tariff:CharField
    - Has Many: Consumption_Time_Points
- ConsumptionTimePoints:
    - id:IntegerField
    - time_point:DateTimeField
    - consumption:FloatField
- UserDataConsumptionTimePoints:
    - user_data_id:IntegerField
    - consumption_time_point_id:IntegerField
    
To handle aggregate data, an additional model should be added:

- TimePointAggregateData:
    - time_point:DateTimeField
    - average:FloatField
    - total:FloatField
    
There was one minor change made to this in the final design, and that is that the UserData id is not autogenerated, but 
is instead the same id as found in the `data\user_data.csv` file. This is done so that interfacing with other systems 
using this id scheme is more seemless. However, it does create the assumption that these ids are checked for uniqueness 
elsewhere, which may not always be desirable. 

Models were also moved into a `models` folder, and into individual files, for better separation of concerns. 

#### Other Possible Options

One different way to store this data is as a single field, with a serialized array or hash holding the consumption 
time points. While this design can be acceptable for smaller objects, in a production version of this challenge, there 
is likely to be a huge number of data points per user, and this means that the serialization overhead could become quite 
large.

Another possibility is to remove the TimePointAggregateData table, and instead generate aggregate data on the fly using 
Django's aggregation methods. The advantage of this is that every time new datapoints are added, their isn't a table 
where every entry must be updated, at the cost of some additional overhead. This approach wasn't chosen, because in the 
challenge importation only happens once, and as such the table only needs to be built a single time.  